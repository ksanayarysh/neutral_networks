# -*- coding: utf-8 -*-
"""task1_compare_nets.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Kz-2Ft6LmR6qrAoIDzOSWts-mGjIPDHv
"""

# Commented out IPython magic to ensure Python compatibility.
from tensorflow.keras.datasets import mnist #Библиотека с базой Mnist
from tensorflow.keras.models import Sequential #НС прямого распространения
from tensorflow.keras.layers import Dense #Полносвязные слой
from tensorflow.keras import utils #Утилиты для to_categorical
from tensorflow.keras.preprocessing import image #Для отрисовки изображения
from google.colab import files #Для загрузки своей картинки
import numpy as np #Библиотека работы с массивами
import matplotlib.pyplot as plt #Отрисовка изображений
from PIL import Image #Отрисовка изображений
#Отрисовывать изображения в ноутбуке, а не в консоль или файл
# %matplotlib inline

(x_train_org, y_train_org), (x_test_org, y_test_org) = mnist.load_data()

x_train = x_train_org.reshape(60000, 784)
x_test = x_test_org.reshape(10000, 784)

x_train = x_train.astype('float32')
x_train = x_train / 255
x_test = x_test.astype('float32')
x_test = x_test / 255

y_train = utils.to_categorical(y_train_org, 10)
y_test = utils.to_categorical(y_test_org, 10)

model = Sequential()

model.add(Dense(800, input_dim=784, activation="relu"))
model.add(Dense(400, activation="relu"))

model.add(Dense(10, activation="softmax"))

model.compile(loss="categorical_crossentropy", optimizer="adam", metrics=["accuracy"])

print(model.summary())

model.fit(x_train, y_train, batch_size=128, epochs=30, verbose=1, validation_split=0.2)

def create_net(neotrons, innner_act, outer_act):
  model = Sequential()
  model.add(Dense(neotrons[0], input_dim=784, activation=innner_act))

  for i in range(1, len(neotrons)):
    model.add(Dense(neotrons[i], activation=innner_act))

  model.add(Dense(10, activation=outer_act))
  model.compile(loss="categorical_crossentropy", optimizer="adam", metrics=["accuracy"])
  print(model.summary())
  return model


def testModel(model, batch_size, epochs, iterations):
  acc = []
  acc_train = []
  
  for i in range(iterations):
    history = model.fit(x_train, y_train, batch_size=batch_size, epochs=epochs, verbose=1, validation_split=0.2)
    # acc.append(history.history["val_acc"][-1])
    # acc_train.append(history.history["val_acc"][-3])
    print(history.history)
  
  return acc, acc_train

models = [
          create_net([800, ], "relu", "softmax"), 
          create_net([800, 400, ], "relu", "softmax"), 
          create_net([800, 400, 400], "relu", "softmax"),
          create_net([800, 400, ], "linear", "softmax"), 
          create_net([400, 400, ], "relu", "sigmoid"), 
          create_net([800, 400, 400, 400], "relu", "softmax")
          ]

for m in models:
  print(m)

print(len(models))



# epochs = [2, 5]
# batch_sizes = [10, 100, 1000, 48000]
batch_sizes = [48000]
epochs=[1]

for e in epochs:
  for b in batch_sizes:
    for model in models:
      acc, acc_train = testModel(model, b, e, 3)
      print(model, "b=", b, "e=", e, round(sum(acc)/len(acc),4), round(sum(acc_train)/len(acc_train),4))

print(models[0].summary())
acc, acc_train = testModel(models[0], b, e, 1)
print(models[0], "b=", b, "e=", e) #, round(sum(acc)/len(acc),4), round(sum(acc_train)/len(acc_train),4))

